# 이진 탐색 트리
'''
루트에서 탐색을 시작
탐색할 키 값을 루트 노드의 키와 비교
키 값보다 루트 노드의 키 값이 더 큰 경우 -> 왼쪽 서브 트리로 이동
키 값보다 루트 노드의 키 값이 더 작은 경우 -> 오른쪽 서브 트리로 이동
'''

'''
삽입 연산
먼저 탐색 연산을 수행하고 삽입할 데이터가 있어야 할 위치에 데이터가 없는 경우,
해당 위치에 삽입
'''

# heap
'''
최솟값과 최댓값을 빠르게 찾기 위해 최대힙(부모노드의 키값이 항상 자식노드보다 큼)과 최소힙을 사용하는데
완전 이진 트리로 구현한다.
(리스트로 구현할 수도 있지만 연산 속도가 느리다. ) 
'''

'''
최대힙에서는 트리의 루트가 항상 최댓값이어야 하기 때문에
힙에서의 삽입 연산시 이를 고려하여야 한다.
완전 이진 트리를 유지하면서 빈 자리에 새로운 데이터를 삽입한다.
삽입 이후에 부모노드와 값을 비교하여 자리를 바꾼다.
(n번 노드에 삽입한 경우 n//2번 노드가 부모노드)
비교할 부모 노드가 없을 때까지 비교를 계속한다. 
'''

'''
힙의 삭제 연산에서는 루트노드의 원소만을 삭제할 수 있다.
(최댓값과 최솟값을 빠르게 꺼내서 쓰기 위한 목적으로 사용하기 때문)
루트 노드의 원소를 삭제한다.
마지막 노드를 임시 변수에 저장한 다음 루트 노드의 값으로 할당한다.
최대힙 규칙에 맞도록 자식 노드와 자리 바꾸기를 반복한다.
(자식 노드가 2개인 경우에 어떤 자식과 먼저 비교?)

'''
# N = 10  # 데이터의 수
# heap = [0]*(N+1)


def enq(n):  # 최대힙에 데이터를 삽입하는 함수
    global last
    last += 1
    heap[last] = n
    p = last // 2
    c = last
    while p > 0 and heap[p] > heap[c]:
        heap[p], heap[c] = heap[c], heap[p]
        c = p
        p = c // 2


# def deq():  # 최대힙에서 삭제 연산을 하고 힙을 갱신
#     global last
#     temp = heap[1]  # 루트의 키값을 임시 변수에 저장
#     heap[1] = heap[last]  # 삭제할 노드의 키값을 루트에 복사
#     last -= 1  # 트리의 마지막 노드를 삭제
#     p = 1
#     c = p * 2  # 왼쪽 자식
#     while c <= last:  # 자식이 하나라도 있다면
#         if c + 1 <= last and heap[c] < heap[c + 1]: # 오른쪽 자식도 있고, 오른쪽 자식이 더 크다면
#             c += 1  # 오른쪽 자식과 비교
#         if heap[p] < heap[c]:  # 자식 노드의 키값이 더 큰 경우
#             heap[p], heap[c] = heap[c], heap[p]  # 자식 노드 키값과 부모 노드의 키값의 위치를 바꾸기
#             p = c  # 자식을 새로운 부모로
#             c = p * 2  # 왼쪽 자식의 번호
#     return temp  # 현재 데이터에서 최댓값을 리턴


# 5177문 - 이진 최소힙 구현하기
# 마지막 노드의 조상 노드의 키값의 합을 구하라

T = int(input())
for tc in range(1, T + 1):
    N = int(input())  # 노드의 수
    arr = list(map(int, input().split()))  # 데이터 입력값
    heap = [0 for _ in range(N+1)]
    last = 0
    for i in arr:
        enq(i)
    result = 0
    par = last // 2
    while par > 0:  # 루트 노드까지 조상을 찾아감
        result += heap[par]
        par //= 2
    print(f'#{tc} {result}')