# 겹치는 구간이 존재한다면 몇 개의 경로가 동시에 겹치는지 카운트
# 겹치는 구간이 없는 경우 -> 1만큼의 시간이 소요
# 겹치는 구간이 생기면 동시에 만나는 학생수가 가장 많은 경우의 학생수가 최소시간이 됨
# 총 200칸의 복도 : 각 복도를 지나는 경로를 카운트
# 방번호의 중복은 없음, 작은방에서 큰방으로 이동한다는 조건은 없음
# 복도를 카운트 배열로 구현 -> cor = [0]*201, 1번 인덱스부터 201번까지 사용
# 출발하는 방번호를 a라고 하면 ((a+(a%2))//2)번 복도가 출발점이 됨
# 도착하는 방번호를 b라고 하면 (b+(b%2))//2)번 복도가 도착점이 됨
# ((a+(a%2))//2)인덱스 부터 (b+(b%2))//2)인덱스까지 카운트 배열의 값을 갱신

T = int(input())

for tc in range(1, T + 1):
    N = int(input())
    cor = [0]*201  # 복도별 지나가는 학생의 수
    for i in range(N):  # 학생의 수
        a, b = map(int, input().split())  # 출발하는 방, 도착하는 방번호
        s = (a+a%2)//2
        e = (b+b%2)//2
        for j in range(min(s, e), max(s, e)+1):
            cor[j] += 1
    print(f'#{tc} {max(cor)}')